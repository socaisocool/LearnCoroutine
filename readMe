


挂起函数中调用resume使协程恢复
suspendCoroutine{
    coroutine->{
       coroutine.resume()//resumeWith
    }
}
上面拿到的coroutine就是下面这个
SafeContinuation{
   intercepted{//上下文配置的拦截器
      $completion//这个就是startCoroutine参数中传的回调complete:Continuation
   }
}
SafeContinuation、intercepted、$completion都是接口Continuation的子类

设置调度器的原理？比如launch(Dispatchers.Default)后，{}中的代码就都运行在调度器的对应线程中？

suspend{协程体} ->编译器->创建一个实现了SuspendLambda(实现BaseContinuationIml(实现Continuation接口))的内部类,在这个内部类中
有一个invokeSuspend函数，这个函数内部实现就是协程体内部的逻辑;也就是说{协程体}是运行在一个Continuation接口子类的invokeSuspend中

jvm运行的Continuation是经过SafeContinuation代理，并由intercepted进行包装的，而例子中intercepted就是DispatcherContext的interceptContinuation，

dispatcher.dispatch {
    delagate.resumeWith(result)
}
delagate(封装类{协程体}的Continuation)是在dispatcher中被调用

协程体中的挂起函数，后面的挂起函数都是处于上一个挂起函数的作用域，比如
suspend{ A,B} 挂起函数A、B、A设置的上下文拦截器是处于子线程，如果B没有设置新的上下文拦截器，那么默认使用的
就是A的上下文拦截器，也会处于子线程中执行

